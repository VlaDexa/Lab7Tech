namespace Lab7Tech
{
    /*
    Многоугольник задан списком вершин в порядке обхода их по часовой стрелке.

    Точка принадлежит многоугольнику, если луч, выпущенный из этой точки в произвольном направлении пересекает стороны многоугольника нечетное количество раз. В случае попадания луча в вершину необходимо выбрать другое направление.

    Реализовать и протестировать метод, принимающий в качестве аргументов координаты точки a и возвращающий:

    "1", если точка a внутри многоугольника;

    "-1", если точка a снаружи многоугольника;

    "0", если точка a лежит на стороне многоугольника.
     */
    public class Point
    {
        public double X { get; set; }
        public double Y { get; set; }

        public Point(double x, double y)
        {
            X = x;
            Y = y;
        }

        public static implicit operator Point((double, double) coordinates)
        {
            return new Point(coordinates.Item1, coordinates.Item2);
        }
    }

    public class Polygon
    {
        private readonly Point[] _points;

        public Polygon(Point[] points)
        {
            _points = points;
        }

        /// <summary>
        /// Проверяет пересекает ли выпущенный из точки вправо луч
        /// </summary>
        /// <param name="first">Начало стороны многоугольника</param>
        /// <param name="second">Конец стороны многоугольника</param>
        /// <param name="point">Точка из которой выпущен луч</param>
        /// <returns>Пересекает ли луч сторону</returns>
        private static bool IsIntersect(Point first, Point second, Point point)
        {
            if (point.X > Math.Max(first.X, second.X))
                return false;

            double max_y, min_y;
            if (first.Y > second.Y)
            {
                max_y = first.Y;
                min_y = second.Y;
            }
            else
            {
                max_y = second.Y;
                min_y = first.Y;
            }
            return (point.Y <= max_y) && (point.Y > min_y);
        }

        /// <summary>
        /// Проверяет лежит ли точка на линии образованной двумя точками
        /// </summary>
        /// <param name="first">Начало отрезка</param>
        /// <param name="second">Конец отрезка</param>
        /// <param name="point">Точка</param>
        /// <returns></returns>
        private static bool IsOnLine(Point first, Point second, Point point, double epsilon = 2.220446049250313e-16)
        {
            if (point.X - Math.Max(first.X, second.X) > epsilon ||
                Math.Min(first.X, second.X) - point.X > epsilon ||
                point.Y - Math.Max(first.Y, second.Y) > epsilon ||
                Math.Min(first.Y, second.Y) - point.Y > epsilon)
                return false;

            if (Math.Abs(second.X - first.X) < epsilon)
                return Math.Abs(first.X - point.X) < epsilon || Math.Abs(second.X - point.X) < epsilon;
            if (Math.Abs(second.Y - first.Y) < epsilon)
                return Math.Abs(first.Y - point.Y) < epsilon || Math.Abs(second.Y - point.Y) < epsilon;

            double x = first.X + (point.Y - first.Y) * (second.X - first.X) / (second.Y - first.Y);
            double y = first.Y + (point.X - first.X) * (second.Y - first.Y) / (second.X - first.X);

            return Math.Abs(point.X - x) < epsilon || Math.Abs(point.Y - y) < epsilon;
        }

        public int IsInside(Point point)
        {
            uint count = 0;
            for (int i = 0, j = 1; i < _points.Length; i++, j = (++j) % _points.Length)
            {
                if (IsOnLine(_points[i], _points[j], point)) return 0;

                count += Convert.ToUInt32(IsIntersect(_points[i], _points[j], point));
            }
            return -1 + (byte)(count % 2) * 2;
        }

        [TestClass]
        public class PolygonTest
        {
            [DataRow(0, 5, 0, -5, -1, 0, true)]
            [DataRow(0, 5, 0, -5, 0, 0, true)]
            [DataRow(0, 5, 0, -5, 1, 0, false)]
            [DataRow(0, 5, 0, -5, 0, -6, false)]
            [DataTestMethod]
            public void TestIntersect(double x1, double y1, double x2, double y2, double x3, double y3, bool expected)
            {
                Point first = new(x1,y1);
                Point second = new(x2, y2);
                Point point = new(x3, y3);

                Assert.AreEqual(expected, IsIntersect(first,second,point));
            }

            [DataRow(0, 5, 0, -5, 0, 0, true)]
            [DataRow(0, 5, 0, -5, 0, 5, true)]
            [DataRow(0, 5, 0, -5, 0, -5, true)]
            [DataRow(0, 5, 0, -5, 0, -6, false)]
            [DataRow(0, 5, 0, -5, 1, 0, false)]
            [DataTestMethod]
            public void TestOnLine(double x1, double y1, double x2, double y2, double x3, double y3, bool expected)
            {
                Point first = new(x1, y1);
                Point second = new(x2, y2);
                Point point = new(x3, y3);

                Assert.AreEqual(expected, IsOnLine(first, second, point));
            }
            
            [DynamicData(nameof(InsideGenerator), DynamicDataSourceType.Method)]
            [DataTestMethod]
            public void TestInside(Polygon poly, Point point, int expected)
            {
                Assert.AreEqual(expected, poly.IsInside(point));
            }

            private static IEnumerable<object[]> InsideGenerator()
            {
                var square = new Polygon(new Point[]
                {
                (0, -5),
                (0,  5),
                (10, 5),
                (15, 0),
                (10,-5)
                });

                // На стороне
                yield return new object[] { square, (Point)(0, 0), 0 };
                // На угле
                yield return new object[] { square, (Point)(0, 5), 0 };
                // Снаружи и на той же X координате что сторона
                yield return new object[] { square, (Point)(0, -6), -1 };
                // Снаружи и на той же Y координате что сторона
                yield return new object[] { square, (Point)(-1, -5), -1 };
                // Где-то снаружи
                yield return new object[] { square, (Point)(-2, 3), -1 };
                // Где-то внутри
                yield return new object[] { square, (Point)(1, 1), 1 };
                // Внутри и на той же Y координате что угол
                yield return new object[] { square, (Point)(1, 0), 1 };
            }
        };
    }
}